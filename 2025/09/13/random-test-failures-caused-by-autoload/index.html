<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#600090"><meta name="msapplication-navbutton-color" content="#600090"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#600090"><meta property="og:image" content="https://khiav223577.github.io/blog/imgs/wolf.jpg"><meta property="og:image" content="/blog/imgs/forest_wolf.png"><meta name="description" content="最近專案升上 Rails 7.2 後，發現測試很容易失敗，但奇怪的是並不是每次都會重現，而且錯誤訊息也非常詭異。例如： 錯誤訊息ActiveRecord::SubclassNotFound:  Invalid single-table inheritance type: User is not a subclass of User NameError:  uninitialized constan"><meta property="og:type" content="article"><meta property="og:title" content="Rails 7.2 中，timecop + autoload 導致的 random test failures｜像哈士奇的狼"><meta property="og:url" content="https://khiav223577.github.io/blog/2025/09/13/random-test-failures-caused-by-autoload/index.html"><meta property="og:site_name" content="狼"><meta property="og:description" content="最近專案升上 Rails 7.2 後，發現測試很容易失敗，但奇怪的是並不是每次都會重現，而且錯誤訊息也非常詭異。例如： 錯誤訊息ActiveRecord::SubclassNotFound:  Invalid single-table inheritance type: User is not a subclass of User NameError:  uninitialized constan"><meta property="og:locale"><meta property="article:published_time" content="2025-09-13T04:29:02.000Z"><meta property="article:modified_time" content="2025-09-13T09:05:09.000Z"><meta property="article:author" content="狼"><meta property="article:tag" content="Rails"><meta name="twitter:card" content="summary"><meta property="fb:app_id" content="172563456645359"><link rel="shortcut icon" href="/blog/imgs/wolf.ico"><link rel="alternate" type="application/atom+xml" title="狼" href="/atom.xml"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"><title>Rails 7.2 中，timecop + autoload 導致的 random test failures｜像哈士奇的狼</title><link rel="canonical" href="https://khiav223577.github.io/blog/2025/09/13/random-test-failures-caused-by-autoload/"><link rel="stylesheet" href="/blog/css/bootstrap.min.css"><link rel="stylesheet" href="/blog/css/blog-style.css"><script async src="/blog/js/algolia.js"></script><script async src="/blog/js/instantsearch.min.js"></script><meta name="generator" content="Hexo 7.3.0"></head><style>header.intro-header{background-image:url(/blog/imgs/water-blue.jpg)}</style><body ontouchstart="" class="animated fadeIn"><nav class="navbar navbar-default navbar-custom navbar-fixed-top" id="nav-top" data-ispost="true" data-istags="false" data-ishome="false" data-isarchive="false"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand animated pulse" href="/blog/">像哈士奇的<span class="brand-logo"> 狼</span></a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/blog/">Home</a></li><li><a href="/blog/archive/">Archive</a></li><li><a href="/blog/categories/">Categories</a></li><li><a href="/blog/tags/">Tags</a></li><li><a href="#search" class="popup-trigger"><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");function handleMagic(e){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout((function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")}),400)):($collapse.style.height="auto",$navbar.className+=" in")}$toggle.addEventListener("click",handleMagic)</script><div class="site-search"><div class="algolia-popup popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div><img class="wechat-title-img" src="/blog/imgs/forest_wolf.png"><style>header.intro-header{background-image:url(/blog/imgs/forest_wolf.png)}</style><header class="intro-header"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center"><div class="post-heading"><h1>Rails 7.2 中，timecop + autoload 導致的 random test failures</h1><span class="meta"><span>作者 狼 </span><span class="spliter">|</span> <span>日期 2025-09-13 </span><span class="spliter">|</span> <span id="busuanzi_container_page_pv"><i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span></span><div class="tags text-center"><a class="tag" href="/blog/tags/#Rails" title="Rails">Rails</a></div></div></div></div></div><div class="post-title-haojen"><span>Rails 7.2 中，timecop + autoload 導致的 random test failures</span></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container"><p>最近專案升上 Rails 7.2 後，發現測試很容易失敗，但奇怪的是並不是每次都會重現，而且錯誤訊息也非常詭異。例如：</p><h3 id="錯誤訊息"><a href="#錯誤訊息" class="headerlink" title="錯誤訊息"></a>錯誤訊息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActiveRecord::SubclassNotFound:</span><br><span class="line">  Invalid single-table inheritance type: User is not a subclass of User</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NameError:</span><br><span class="line">  uninitialized constant User</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActiveRecord::AssociationTypeMismatch:</span><br><span class="line">  User(#548920) expected, got #&lt;User ...&gt; which is an instance of User(#95540)</span><br></pre></td></tr></table></figure><h2 id="Trace-root-cause"><a href="#Trace-root-cause" class="headerlink" title="Trace root cause"></a>Trace root cause</h2><h3 id="1-重現錯誤"><a href="#1-重現錯誤" class="headerlink" title="1. 重現錯誤"></a>1. 重現錯誤</h3><p>第一步是先能在 local 重現錯誤。我們可以先從 CI&#x2F;CD 的 log 記錄中，找到 rspec 指令。上面應該會帶 <code>--seed</code> 參數，用這個 seed 我們能先在 local 重現噴錯的測試。能夠重現錯誤是關鍵的一步，接下來我們就能慢慢找 root cause。</p><h3 id="2-降低重現的時間"><a href="#2-降低重現的時間" class="headerlink" title="2. 降低重現的時間"></a>2. 降低重現的時間</h3><p>因為 CI&#x2F;CD 會跑整個專案的所有測試，耗時太長，不方便快速驗證修改是否有效。這時可以利用 <code>--bisect</code> 參數，讓 rspec 自動幫我們用二分法找出最小測資組合，只需要執行兩個 test case 就能重現錯誤，大幅縮短 debug 時間。</p><h3 id="3-異常的-reload"><a href="#3-異常的-reload" class="headerlink" title="3. 異常的 reload"></a>3. 異常的 reload</h3><p>有了快速重現步驟後，我們觀察到測試執行時間異常的長。用 print 大法後，發現卡住的地方並不在專案程式碼內，而是在 Rails 內部。</p><p>從上面錯誤訊息推測，User 常數不屬於 User 自己，猜測可能是測試執行的過程中，不明原因觸發 auto hot reload 了，導致常數改變。改變前的 User 被認定跟改變後的 User 不同，因此噴了這種錯誤訊息。</p><h3 id="4-trace-caller"><a href="#4-trace-caller" class="headerlink" title="4. trace caller"></a>4. trace caller</h3><p>從 Rails 的 source code 中，我們找到 autoloader 有 <code>on_unload</code> 這個 callback 函式。</p><p>因此我們能在 initializer 插入一段 code，檢查是誰呼叫到 <code>on_unload</code>，並將將 caller 印出來，追查呼叫者。</p><figure class="highlight rb"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Rails</span>.autoloaders.each <span class="keyword">do</span> |<span class="params">loader</span>|</span><br><span class="line">  loader.on_unload <span class="keyword">do</span> |<span class="params">*args</span>|</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$debug</span></span><br><span class="line">      p “------ <span class="title class_">Rails</span>.autoloaders <span class="symbol">on_unload:</span> <span class="comment">#&#123;args&#125; -------”</span></span><br><span class="line">      caller.each&#123;|<span class="params">s</span>| p s &#125;</span><br><span class="line">      exit</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="找出觸發的-autoloader"><a href="#找出觸發的-autoloader" class="headerlink" title="找出觸發的 autoloader"></a>找出觸發的 autoloader</h3><p>從 caller 追蹤到最可疑的一段：<code>/.rvm/gems/ruby-3.3.9/gems/activesupport-7.2.2.1/lib/active_support/reloader.rb:64</code></p><figure class="highlight rb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.check! <span class="comment"># :nodoc:</span></span><br><span class="line">  <span class="variable">@should_reload</span> |<span class="params"></span>|= check.call</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>也就是 check 這個 lambda 回傳 true 時，就會觸發 autoload。接著我們可以在整個 rails gem 中搜尋 <code>check</code> 這個字串，找到這個 lambda 被定義的地方。最後找到：</p><figure class="highlight rb"><table><tr><td class="code"><pre><span class="line">app.reloader.check = <span class="built_in">lambda</span> <span class="keyword">do</span></span><br><span class="line">  app.reloaders.map(&amp;<span class="symbol">:updated?</span>).any?</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接著使用 print 大法，我們找到是 <code>ActionView::CacheExpiry::ViewReloader</code> 不明原因 <code>updated?</code> 回傳 true，導致觸發 autoload。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p app.reloaders.map(&amp;:updated?)</span><br><span class="line"># =&gt; [false, true, false, false, false]</span><br><span class="line"></span><br><span class="line">p app.reloaders.map&#123;|s| s.class.name &#125;</span><br><span class="line"># =&gt; [“ActiveSupport::FileUpdateChecker”, “ActionView::CacheExpiry::ViewReloader”, “ActiveSupport::FileUpdateChecker”, “Rails::Application::RoutesReloader”, “ActiveSupport::FileUpdateChecker”]</span><br></pre></td></tr></table></figure><h2 id="random-test-failures-原因"><a href="#random-test-failures-原因" class="headerlink" title="random test failures 原因"></a>random test failures 原因</h2><p>關鍵在於 Rails 7.2 的這個 <a target="_blank" rel="noopener" href="https://github.com/rails/rails/pull/51308">PR</a>，為了效能的考量，將 reloader 改成了 lazy load。原本 reloader 初始化時會跑的 <code>view_reloader.execute</code>，現在變成第一次檢查是否要 reload 時才執行，造成檔案時間戳（mtime）判斷出現落差。</p><p>然後再搭配以下流程就會觸發 bug：</p><ul><li><p>test case 在打 API 時，reloader 會去判斷需不需要重載 class。</p></li><li><p>但此時我們若有用 Timecop.freeze 或是 travel_to 函式去控制時間的話，Time.now 的時間可能是過去的時間。</p></li><li><p>而因為 ActiveSupport::FileUpdateChecker 在抓 <code>max_mtime</code> 時，會去 ignore 檔案 mtime 在未來的那些檔案。（可能是認為這檔案時間竟然在未來，太怪了所以 ignore (?)）</p><figure class="highlight rb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_mtime</span>(<span class="params">paths</span>)</span><br><span class="line">  time_now = <span class="title class_">Time</span>.now</span><br><span class="line">  max_mtime = <span class="literal">nil</span></span><br><span class="line">  <span class="comment"># Time comparisons are performed with #compare_without_coercion because</span></span><br><span class="line">  <span class="comment"># AS redefines these operators in a way that is much slower and does not</span></span><br><span class="line">  <span class="comment"># bring any benefit in this particular code.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># Read t1.compare_without_coercion(t2) &lt; 0 as t1 &lt; t2.</span></span><br><span class="line">  paths.each <span class="keyword">do</span> |<span class="params">path</span>|</span><br><span class="line">    mtime = <span class="title class_">File</span>.mtime(path)</span><br><span class="line">    <span class="keyword">next</span> <span class="keyword">if</span> time_now.compare_without_coercion(mtime) &lt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> max_mtime.<span class="literal">nil</span>? |<span class="params"></span>| max_mtime.compare_without_coercion(mtime) &lt; <span class="number">0</span></span><br><span class="line">      max_mtime = mtime</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  max_mtime</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>因為部份檔案的 mtime 被 ignore 了，導致 <code>max_mtime</code> 算出來比實際小一點</p></li><li><p>在另一支測試打 API 時，因為沒有 Timecop.freeze，或是 freeze 的時間在比較晚一點的時間</p></li><li><p>因此比較少檔案被 ignore，使得 <code>max_mtime</code> 算出來的變大，而導致 reloader 誤以為有新檔案變動，而判斷需要 reload</p></li></ul><h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>由於我們在跑測試時，不會再去改動檔案，因此也不需要去判斷要不要 reload。因此在 CI&#x2F;CD 環境中，我們可以直接關閉關閉測試環境的 reloader 就好，避免測試過程中 reload，不但耗時，也可能會產生 random fails。<br>改法是：</p><ol><li><code>config/environments/test.rb</code> 中，設定 <code>config.cache_classes = true</code></li><li>因為 spring 是先跑在背景，靠 reload 機制載入 file changes，因此也要再設定 ENV <code>DISABLE_SPRING=1</code> 來關閉 spring</li></ol><hr><ul class="pager"><li class="previous"><a href="/blog/2025/03/30/Implementing-use-index-in-Rails/" data-toggle="tooltip" data-placement="top" title="在 Active Record 中手動指定 SQL 查詢索引">&larr; Previous Post</a></li></ul><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="hidden-xs col-sm-3 toc-col"><div class="toc-wrap"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%8C%AF%E8%AA%A4%E8%A8%8A%E6%81%AF"><span class="toc-text">錯誤訊息</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#Trace-root-cause"><span class="toc-text">Trace root cause</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%87%8D%E7%8F%BE%E9%8C%AF%E8%AA%A4"><span class="toc-text">1. 重現錯誤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%99%8D%E4%BD%8E%E9%87%8D%E7%8F%BE%E7%9A%84%E6%99%82%E9%96%93"><span class="toc-text">2. 降低重現的時間</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%95%B0%E5%B8%B8%E7%9A%84-reload"><span class="toc-text">3. 異常的 reload</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-trace-caller"><span class="toc-text">4. trace caller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E8%A7%B8%E7%99%BC%E7%9A%84-autoloader"><span class="toc-text">找出觸發的 autoloader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#random-test-failures-%E5%8E%9F%E5%9B%A0"><span class="toc-text">random test failures 原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95"><span class="toc-text">解決方法</span></a></li></div></div></div></div></article><script type="text/javascript">var disqus_shortname="khiav-blog-1",disqus_identifier="https://khiav223577.github.io/blog/2025/09/13/random-test-failures-caused-by-autoload/",disqus_url="https://khiav223577.github.io/blog/2025/09/13/random-test-failures-caused-by-autoload/";!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src="https://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",(function(e){n(null,e)}),!1),c.parentNode.insertBefore(r,c)}</script><script>async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",(function(){anchors.options={visible:"hover",placement:"right"},anchors.add().remove(".intro-header h1").remove(".subheading").remove(".sidebar-container h5")}))</script><style>@media all and (min-width:800px){.anchorjs-link{position:absolute;left:-.75em;font-size:1.1em;margin-top:-.1em}}</style><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center"><br><div class="sidebar-container" style="padding:0"><div style="margin-top:20px"><h5 class="text-center">友情連結</h5><ul class="list-inline text-center"><li><a target="_blank" href="https://store.steampowered.com/app/751320">回音 steam</a></li><li><a target="_blank" href="https://www.pagamo.org">PaGamO</a></li><li><a target="_blank" href="https://max.maicoin.com/signup?r=92d039f1">MAX 交易所</a></li></ul></div></div><ul class="list-inline text-center" style="margin-top:25px"><li><a target="_blank" href="https://www.facebook.com/moon.moon.notes"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fab fa-facebook-f fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://github.com/khiav223577"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://www.linkedin.com/in/rumble-huang"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 狼 2025<br><span><span id="busuanzi_container_site_pv"><i class="fa fa-eye" style="margin-right:3px" data-toggle="tooltip" title="本站總訪問量"></i> <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span> </span><span style="margin:0 5px">| </span><span id="busuanzi_container_site_uv"><i class="fa fa-user" style="margin-right:2px" data-toggle="tooltip" title="本站總訪客數"></i> <span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span></span></span><br><br>Theme by <a target="_blank" href="https://haojen.github.io/">Haojen Ma</a></p></div></div></div></footer><script src="/blog/js/jquery.min.js"></script><script src="/blog/js/bootstrap.min.js"></script><script src="/blog/js/blog.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",(function(e){n(null,e)}),!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("https://khiav223577.github.io/blog/js/jquery.tagcloud.js",(function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()}))</script><script>async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js",(function(){var c=document.querySelector("nav");c&&FastClick.attach(c)}))</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-LERHN3QS29"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-LERHN3QS29")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/blog/js/run_prettify.js"></script><script>$((function(){$("pre > code[class]").addClass("prettyprint"),PR.prettyPrint()}))</script><img class="wechat-title-img" src="/blog/imgs/wolf.jpg"></body></html>